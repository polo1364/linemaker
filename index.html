<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LINEè²¼åœ–è£½ä½œå·¥å…·</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Microsoft JhengHei', sans-serif;
      background: linear-gradient(135deg, #f5f0ff 0%, #ffe0f0 50%, #e0f0ff 100%);
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      padding: 20px;
      border-radius: 15px;
      margin-bottom: 30px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    h1 {
      background: linear-gradient(135deg, #9333ea 0%, #ec4899 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-size: 2em;
      text-align: center;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    @media (max-width: 968px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: white;
      border-radius: 15px;
      padding: 25px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    .card-title {
      font-size: 1.3em;
      font-weight: bold;
      margin-bottom: 10px;
      color: #333;
    }

    .card-desc {
      color: #666;
      margin-bottom: 20px;
      font-size: 0.9em;
    }

    .upload-area {
      border: 2px dashed #ccc;
      border-radius: 10px;
      padding: 40px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      min-height: 200px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .upload-area:hover {
      border-color: #9333ea;
      background: #f9f5ff;
    }

    .upload-area img {
      max-width: 100%;
      max-height: 300px;
      border-radius: 10px;
    }

    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #333;
    }

    select, input[type="range"] {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 1em;
    }

    button {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      margin-top: 10px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #9333ea 0%, #ec4899 100%);
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(147, 51, 234, 0.4);
    }

    .btn-secondary {
      background: #f3f4f6;
      color: #333;
    }

    .btn-secondary:hover {
      background: #e5e7eb;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .sticker-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin-top: 20px;
    }

    .sticker-item {
      position: relative;
      aspect-ratio: 688/512;
      border: 1px solid #ddd;
      border-radius: 8px;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.3s;
    }

    .sticker-item:hover {
      transform: scale(1.05);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    .sticker-item img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e5e7eb;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 10px;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(135deg, #9333ea 0%, #ec4899 100%);
      transition: width 0.3s;
    }

    .status-text {
      text-align: center;
      color: #666;
      margin-top: 10px;
      font-size: 0.9em;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal.show {
      display: flex;
    }

    .modal-content {
      background: white;
      padding: 30px;
      border-radius: 15px;
      max-width: 500px;
      width: 90%;
    }

    .modal-title {
      font-size: 1.5em;
      font-weight: bold;
      margin-bottom: 10px;
    }

    .modal-desc {
      color: #666;
      margin-bottom: 20px;
    }

    input[type="password"], input[type="text"] {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 1em;
      margin-bottom: 15px;
    }

    .generated-image {
      width: 100%;
      border-radius: 10px;
      margin-bottom: 15px;
    }

    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .icon {
      width: 48px;
      height: 48px;
      color: #999;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>LINEè²¼åœ–è£½ä½œå·¥å…·</h1>
    </header>

    <div class="main-grid">
      <!-- Left Panel -->
      <div>
        <!-- Upload Card -->
        <div class="card">
          <div class="card-title">1. ä¸Šå‚³è§’è‰²åœ–ç‰‡</div>
          <div class="card-desc">æ”¯æŒPNGã€JPGæ ¼å¼</div>
          <div class="upload-area" id="uploadArea">
            <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
            </svg>
            <p>é»æ“Šä¸Šå‚³åœ–ç‰‡</p>
          </div>
          <input type="file" id="fileInput" accept="image/png,image/jpeg" style="display: none;">
        </div>

        <!-- Settings Card -->
        <div class="card" style="margin-top: 20px;">
          <div class="card-title">2. é¸æ“‡é¢¨æ ¼è¨­å®š</div>
          <div class="card-desc">è‡ªå®šç¾©è²¼åœ–ä¸»é¡Œã€é¢¨æ ¼å’Œå­—é«”</div>
          
          <div class="form-group">
            <label>ä¸»é¡Œ</label>
            <select id="themeSelect"></select>
          </div>

          <div class="form-group">
            <label>é¢¨æ ¼</label>
            <select id="styleSelect"></select>
          </div>

          <div class="form-group">
            <label>å­—é«”</label>
            <select id="fontSelect"></select>
          </div>

          <div class="form-group">
            <label>ç™½é‚Šå¯¬åº¦: <span id="borderValue">10</span>px</label>
            <input type="range" id="borderWidth" min="0" max="30" value="10">
          </div>

          <button class="btn-secondary" onclick="showApiKeyModal()">âš™ï¸ è¨­ç½®API Key</button>
          <button class="btn-primary" id="generateBtn" onclick="handleGenerate()">
            ğŸ¨ ç”Ÿæˆè²¼åœ–
          </button>
        </div>
      </div>

      <!-- Right Panel -->
      <div>
        <!-- Generated Image -->
        <div class="card" id="generatedCard" style="display: none;">
          <div class="card-title">3. ç”Ÿæˆçš„è²¼åœ–</div>
          <div class="card-desc">AIç”Ÿæˆçš„12å®®æ ¼è²¼åœ–</div>
          <img id="generatedImage" class="generated-image">
          <button class="btn-primary" onclick="handleProcess()">
            âœ‚ï¸ è™•ç†è²¼åœ–ï¼ˆå»èƒŒ+è£åˆ‡+ç™½é‚Šï¼‰
          </button>
        </div>

        <!-- Stickers Grid -->
        <div class="card" id="stickersCard" style="display: none;">
          <div class="card-title">4. è™•ç†å®Œæˆ</div>
          <div class="card-desc">12å¼µç¨ç«‹è²¼åœ–</div>
          <div class="sticker-grid" id="stickerGrid"></div>
          <button class="btn-primary" onclick="downloadAllAsZip()">
            ğŸ“¦ ä¸‹è¼‰å…¨éƒ¨ï¼ˆZIPï¼‰
          </button>
        </div>

        <!-- Progress -->
        <div class="card" id="progressCard" style="display: none;">
          <div class="status-text" id="statusText">è™•ç†ä¸­...</div>
          <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- API Key Modal -->
  <div class="modal" id="apiKeyModal">
    <div class="modal-content">
      <div class="modal-title">è¨­ç½®Gemini API Key</div>
      <div class="modal-desc">
        è«‹è¼¸å…¥æ‚¨çš„Google Gemini API Keyã€‚æ‚¨å¯ä»¥åœ¨
        <a href="https://aistudio.google.com/apikey" target="_blank">Google AI Studio</a>
        ç²å–å…è²»API Keyã€‚
      </div>
      <input type="password" id="apiKeyInput" placeholder="è¼¸å…¥API Key">
      <button class="btn-primary" onclick="saveApiKey()">ç¢ºèª</button>
    </div>
  </div>

  <canvas id="canvas" style="display: none;"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    // Constants
    const THEME_PROMPTS = {
      "ç¤¾ç•œæ—¥å¸¸ (é è¨­)": "Corporate Slave (ç¤¾ç•œ) daily office life (e.g., tired, fake smile, drinking coffee, typing furiously, salary day, overtime, I want to go home).",
      "æ—¥å¸¸ç”Ÿæ´»": "Daily Life (æ—¥å¸¸ç”Ÿæ´»), casual interactions, greetings (Hello, Good night, OK, Thanks), sleeping, eating, playing phone, daily struggles.",
      "å–œæ€’å“€æ¨‚": "Emotional Expressions (å–œæ€’å“€æ¨‚), exaggerated facial expressions, happy, angry, sad, joyful, crying, laughing out loud, shocked, rolling eyes.",
      "æ—¥æœ¬æ—…éŠ": "Japan Travel (æ—¥æœ¬æ—…éŠ), sightseeing, eating ramen, hot springs, kimono, taking photos, shopping, excited tourist vibes, flight, luggage.",
      "æƒ…ä¾¶æ”¾é–ƒ": "Couples in Love (æƒ…ä¾¶æ”¾é–ƒ), romantic gestures, hugging, kissing, missing you, heart eyes, sweet moments, dating, love you.",
      "è€å»¢äººç”Ÿ": "Lazy Life (è€å»¢äººç”Ÿ), lying in bed, potato couch, refusing to work, sleepy, messy hair, eating snacks, doing nothing, don't bother me.",
      "ç¾é£Ÿåƒè²¨": "Foodie Life (ç¾é£Ÿåƒè²¨), drooling, eating huge meals, drinking boba tea, hungry, satisfied, food coma, midnight snack, yummy.",
      "é‹å‹•å¥èº«": "Workout & Fitness (é‹å‹•å¥èº«), gym, running, yoga, sweating, muscles, tired after workout, protein shake, motivation, weight loss.",
      "è²“å¥´æ—¥å¸¸": "Cat Lover (è²“å¥´æ—¥å¸¸), playing with cats, feeding, cleaning litter, being ignored by cat, cat ears, cute paws, meow.",
      "ç‹—æ´¾ç”Ÿæ´»": "Dog Lover (ç‹—æ´¾ç”Ÿæ´»), walking dog, playing fetch, happy tail wagging, puppy eyes, loyal companion, messy room, woof.",
      "æ–°æ‰‹çˆ¸åª½": "New Parents (æ–°æ‰‹çˆ¸åª½), feeding baby, changing diapers, tired eyes, baby crying, happy family, holding baby, milk bottle.",
      "æ ¡åœ’ç”Ÿæ´»": "School Life (æ ¡åœ’ç”Ÿæ´»), studying, exams, recess, homework, graduation, crush on classmate, teacher scolding, reading books.",
      "ç¯€æ—¥æ…¶ç¥": "Festival Celebration (ç¯€æ—¥æ…¶ç¥), Birthday, New Year, Christmas, red envelopes, party poppers, cake, fireworks, congratulations.",
      "ç¶²è·¯ç”¨èª": "Internet Slang (ç¶²è·¯ç”¨èª), LOL, OMG, facepalm, trending memes, keyboard warrior, like & subscribe, +1.",
      "è¿·å› æ¢—åœ–": "Trending Memes (è¿·å› æ¢—åœ–), funny poses, viral internet culture references, sarcastic humor, troll face vibes, funny faces.",
      "æ­£èƒ½é‡èªéŒ„": "Positive Vibes (æ­£èƒ½é‡èªéŒ„), fighting!, you can do it, good morning, thumbs up, sunshine, motivation, cheer up.",
      "è² èƒ½é‡é‡‹æ”¾": "Negative Energy (è² èƒ½é‡é‡‹æ”¾), depression, dark cloud, soul leaving body, giving up, I want to go home, social battery dead."
    };

    const STYLE_PROMPTS = {
      "åŸç‰ˆé¢¨æ ¼": "Keep the original style of the input image, consistent character design.",
      "å¯«å¯¦å…‰å½±": "Photorealistic, hyperrealistic, cinematic lighting, highly detailed textures, natural colors, ray tracing, global illumination, depth of field, sharp focus, 8k resolution, photographic quality, realistic shadows.",
      "æ—¥å¼æ¼«ç•«": "Japanese anime style, light novel illustration, mobile game CG, official art, high quality, vibrant colors, cel shading, high-gloss finish, glowing effects, bloom, rim lighting, pastel blue and white color palette.",
      "ç¾å¼æ¼«ç•«": "American comic book style, graphic novel art, bold outlines, heavy inking, cross-hatching shadows, high contrast, vibrant and saturated colors, halftone dots texture, dynamic composition, retro comic feel, muscular anatomy.",
      "éŸ“å¼æ¼«ç•«": "Korean webtoon, manhwa style, high quality, high detail, smooth coloring, clean lineart, volumetric lighting, pastel colors, glowing skin, subtle shading.",
      "ä¸­å¼æ°´å¢¨ç•«": "Traditional Chinese ink painting, guohua style, ink wash painting, expressive brush strokes, flowing ink, calligraphy strokes, watercolor blend, monochrome palette with muted earthy tones, rice paper texture, negative space, atmospheric.",
      "å¯æ„›Qç‰ˆæ¼«ç•«": "Chibi style, super deformed (SD), cute, kawaii, simplified anatomy, large heads small bodies, clean thick lines, soft coloring, pastel color palette, cheerful atmosphere, expressive faces, sticker art style.",
      "è¿ªå£«å°¼é¢¨æ ¼å‹•ç•«": "Disney animation style, Pixar style, stylized 3D render, highly polished, expressive character design, appealing soft shapes, vibrant and warm color palette, soft global illumination, subsurface scattering, fairytale atmosphere, cinematic feel.",
      "åƒç´ é¢¨æ ¼": "Pixel art, 8-bit style, 16-bit retro game, low resolution, dot art, visible grid, limited color palette, distinct pixels, dithering shading, nostalgic aesthetic, sprite art.",
      "3Dæ¸²æŸ“é¢¨æ ¼": "3D render, CGI illustration, highly detailed models, realistic textures, physically based rendering (PBR), octane render style, complex lighting, volumetric fog, sharp focus, digital sculpting, clean render pass."
    };

    const FONT_STYLES = {
      "é»‘é«” (é è¨­)": "Bold Sans-serif, Heiti style, modern, clean, high legibility, standard sticker font",
      "åœ“é«” (å¯æ„›æŸ”å’Œ)": "Rounded Sans-serif, YuanTi style, soft edges, cute, friendly, kawaii typography",
      "æ‰‹å¯«é«” (éš¨æ€§å¡—é´‰)": "Handwritten style, marker pen, casual, personal, messy but cute, notebook doodle style",
      "æ›¸æ³•é«” (æ°£å‹¢ç£…ç¤´)": "Chinese Calligraphy, brush strokes, energetic, traditional ink style, powerful lines",
      "POPé«” (æ´»æ½‘æµ·å ±)": "POP art style, bold bubble letters, heavy outlines, advertisement style, vivid and bouncy",
      "åƒç´ é«” (å¾©å¤éŠæˆ²)": "Pixel font, 8-bit, retro gaming style, blocky, jagged edges, digital look",
      "ç¶œè—é«” (èª‡å¼µé†’ç›®)": "Variety show subtitle style, extra bold, exaggerated strokes, attention-grabbing, TV show font",
      "å¨ƒå¨ƒé«” (ç«¥è¶£å¯æ„›)": "Childish font, crayon style, playful, naive, irregular sizes, kindergarten style"
    };

    const STICKER_CONFIG = {
      COLS: 4,
      ROWS: 3,
      CELL_WIDTH: 688,
      CELL_HEIGHT: 512
    };

    // State
    let apiKey = localStorage.getItem('gemini_api_key') || '';
    let uploadedImage = null;
    let generatedImage = null;
    let stickers = [];
    let loading = false;

    // Initialize
    function init() {
      // Populate selects
      const themeSelect = document.getElementById('themeSelect');
      Object.keys(THEME_PROMPTS).forEach(theme => {
        const option = document.createElement('option');
        option.value = theme;
        option.textContent = theme;
        themeSelect.appendChild(option);
      });

      const styleSelect = document.getElementById('styleSelect');
      Object.keys(STYLE_PROMPTS).forEach(style => {
        const option = document.createElement('option');
        option.value = style;
        option.textContent = style;
        styleSelect.appendChild(option);
      });

      const fontSelect = document.getElementById('fontSelect');
      Object.keys(FONT_STYLES).forEach(font => {
        const option = document.createElement('option');
        option.value = font;
        option.textContent = font;
        fontSelect.appendChild(option);
      });

      // Event listeners
      document.getElementById('uploadArea').addEventListener('click', () => {
        document.getElementById('fileInput').click();
      });

      document.getElementById('fileInput').addEventListener('change', handleFileUpload);

      document.getElementById('borderWidth').addEventListener('input', (e) => {
        document.getElementById('borderValue').textContent = e.target.value;
      });
    }

    function handleFileUpload(e) {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          uploadedImage = event.target.result;
          const uploadArea = document.getElementById('uploadArea');
          uploadArea.innerHTML = `<img src="${uploadedImage}" alt="Uploaded">`;
          
          // Reset
          generatedImage = null;
          stickers = [];
          document.getElementById('generatedCard').style.display = 'none';
          document.getElementById('stickersCard').style.display = 'none';
        };
        reader.readAsDataURL(file);
      }
    }

    function showApiKeyModal() {
      document.getElementById('apiKeyModal').classList.add('show');
      document.getElementById('apiKeyInput').value = apiKey;
    }

    function saveApiKey() {
      apiKey = document.getElementById('apiKeyInput').value;
      if (apiKey) {
        localStorage.setItem('gemini_api_key', apiKey);
        document.getElementById('apiKeyModal').classList.remove('show');
        alert('API Keyå·²ä¿å­˜ï¼');
      } else {
        alert('è«‹è¼¸å…¥API Key');
      }
    }

    async function handleGenerate() {
      if (!apiKey) {
        showApiKeyModal();
        return;
      }

      if (!uploadedImage) {
        alert('è«‹å…ˆä¸Šå‚³ä¸€å¼µè§’è‰²åœ–ç‰‡ï¼');
        return;
      }

      loading = true;
      showProgress('æ­£åœ¨å‘¼å«AIè¨­è¨ˆå¸«ç”Ÿæˆè²¼åœ–...', 10);
      document.getElementById('generateBtn').disabled = true;

      try {
        const theme = document.getElementById('themeSelect').value;
        const style = document.getElementById('styleSelect').value;
        const font = document.getElementById('fontSelect').value;

        const MODEL_NAME = "gemini-3-pro-image-preview";
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`;

        const base64Image = uploadedImage.split(',')[1];
        const themeDescription = THEME_PROMPTS[theme];
        const styleDescription = STYLE_PROMPTS[style];
        const fontDescription = FONT_STYLES[font];

        const promptText = `
Create a sprite sheet of 12 Line stickers (4 columns x 3 rows).

Requirements:
1. Character: Based on the input image provided.
2. Theme: "${themeDescription}"
3. Text: Include funny phrases related to the theme. 
   - **IMPORTANT**: ALL TEXT MUST BE IN **TRADITIONAL CHINESE (ç¹é«”ä¸­æ–‡)**. Do NOT use Simplified Chinese or English.
4. Typography: 
   - Style: "${fontDescription}"
   - Color: Use vibrant, lively colors (e.g., bright orange, hot pink, cyan, red, purple). **ABSOLUTELY NO GREEN** or colors close to RGB(0, 255, 0) for text, as it will be removed by the green screen filter.
   - Effects: **MUST add a 2-3px thick WHITE OUTLINE (stroke)** around all text to ensure readability on any background.
   - Size: Large, legible, and integrated into the sticker design.
5. Layout: Strictly arrange in a grid of 4 columns and 3 rows. The total image aspect ratio is 16:9.
6. Background: Use a **pure green screen background (RGB 0, 255, 0)** for the entire canvas. This green will be removed later.
7. Style: "${styleDescription}"
8. Output: A single image containing all 12 stickers in a 4x3 grid layout.

IMPORTANT:
- Each sticker should have distinct poses and expressions.
- Text must be in Traditional Chinese with white outlines.
- Background MUST be pure green (RGB 0, 255, 0).
- NO green colors in the character or text.
        `;

        updateProgress(30);

        const response = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            contents: [{
              parts: [
                { text: promptText },
                {
                  inline_data: {
                    mime_type: "image/png",
                    data: base64Image
                  }
                }
              ]
            }],
            generationConfig: {
              responseModalities: ["TEXT", "IMAGE"],
              imageConfig: {
                aspectRatio: "16:9",
                imageSize: "2K"
              }
            }
          })
        });

        if (!response.ok) {
          const errData = await response.json();
          console.error('API Error:', errData);
          throw new Error(errData.error?.message || 'APIè«‹æ±‚å¤±æ•—');
        }

        const data = await response.json();
        console.log('API Response:', data);
        
        // å˜—è©¦å¾ä¸åŒä½ç½®æå–åœ–ç‰‡
        let generatedImageData = null;
        
        if (data.candidates && data.candidates.length > 0) {
          const candidate = data.candidates[0];
          if (candidate.content && candidate.content.parts) {
            for (const part of candidate.content.parts) {
              if (part.inlineData && part.inlineData.mimeType && part.inlineData.mimeType.startsWith('image')) {
                generatedImageData = part.inlineData.data;
                console.log('Found image in inlineData with mimeType:', part.inlineData.mimeType);
                break;
              }
              if (part.inline_data && part.inline_data.mime_type && part.inline_data.mime_type.startsWith('image')) {
                generatedImageData = part.inline_data.data;
                console.log('Found image in inline_data with mime_type:', part.inline_data.mime_type);
                break;
              }
            }
          }
        }

        if (!generatedImageData) {
          console.error('No image found in response. Full response:', JSON.stringify(data, null, 2));
          throw new Error('AIæœªè¿”å›åœ–ç‰‡ã€‚å¯èƒ½åŸå› ï¼š1) å…§å®¹è¢«å®‰å…¨éæ¿¾ 2) APIé…é¡ç”¨ç›¡ 3) æ¨¡å‹ä¸æ”¯æŒåœ–ç‰‡ç”Ÿæˆã€‚è«‹æŸ¥çœ‹æ§åˆ¶å°è©³ç´°ä¿¡æ¯ã€‚');
        }

        generatedImage = `data:image/png;base64,${generatedImageData}`;
        document.getElementById('generatedImage').src = generatedImage;
        document.getElementById('generatedCard').style.display = 'block';

        updateProgress(100);
        hideProgress();
        alert('è²¼åœ–ç”ŸæˆæˆåŠŸï¼');
      } catch (error) {
        console.error('Generation Error:', error);
        alert('ç”Ÿæˆå¤±æ•—ï¼š' + error.message);
        hideProgress();
      } finally {
        loading = false;
        document.getElementById('generateBtn').disabled = false;
      }
    }

    async function handleProcess() {
      if (!generatedImage) {
        alert('è«‹å…ˆç”Ÿæˆè²¼åœ–ï¼');
        return;
      }

      showProgress('æ­£åœ¨å»èƒŒ...', 20);

      try {
        // 1. Remove green screen
        const removedBg = await removeGreenScreen(generatedImage);
        updateProgress(40);

        // 2. Crop stickers
        showProgress('æ­£åœ¨è£åˆ‡è²¼åœ–...', 40);
        const cropped = await cropStickers(removedBg);
        updateProgress(60);

        // 3. Add white border
        showProgress('æ­£åœ¨æ·»åŠ ç™½é‚Š...', 60);
        const borderWidth = parseInt(document.getElementById('borderWidth').value);
        stickers = await addWhiteBorderBatch(cropped, borderWidth);
        updateProgress(80);

        // 4. Display stickers
        displayStickers();
        updateProgress(100);
        hideProgress();

        document.getElementById('stickersCard').style.display = 'block';
        alert('è™•ç†å®Œæˆï¼');
      } catch (error) {
        console.error('Processing Error:', error);
        alert('è™•ç†å¤±æ•—ï¼š' + error.message);
        hideProgress();
      }
    }

    function removeGreenScreen(imageUrl, threshold = 50) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);

          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;

          for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];

            if (g > r + threshold && g > b + threshold && g > 100) {
              data[i + 3] = 0;
            }
          }

          ctx.putImageData(imageData, 0, 0);
          resolve(canvas.toDataURL('image/png'));
        };

        img.onerror = () => reject(new Error('åœ–ç‰‡åŠ è¼‰å¤±æ•—'));
        img.src = imageUrl;
      });
    }

    function cropStickers(imageUrl) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        
        img.onload = () => {
          const { COLS, ROWS, CELL_WIDTH, CELL_HEIGHT } = STICKER_CONFIG;
          const stickers = [];

          for (let row = 0; row < ROWS; row++) {
            for (let col = 0; col < COLS; col++) {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');

              canvas.width = CELL_WIDTH;
              canvas.height = CELL_HEIGHT;

              const sx = (img.width / COLS) * col;
              const sy = (img.height / ROWS) * row;
              const sw = img.width / COLS;
              const sh = img.height / ROWS;

              ctx.drawImage(img, sx, sy, sw, sh, 0, 0, CELL_WIDTH, CELL_HEIGHT);
              stickers.push(canvas.toDataURL('image/png'));
            }
          }

          resolve(stickers);
        };

        img.onerror = () => reject(new Error('åœ–ç‰‡åŠ è¼‰å¤±æ•—'));
        img.src = imageUrl;
      });
    }

    function addWhiteBorder(imageUrl, borderWidth) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');

          canvas.width = img.width + borderWidth * 2;
          canvas.height = img.height + borderWidth * 2;

          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, borderWidth, borderWidth);

          resolve(canvas.toDataURL('image/png'));
        };

        img.onerror = () => reject(new Error('åœ–ç‰‡åŠ è¼‰å¤±æ•—'));
        img.src = imageUrl;
      });
    }

    async function addWhiteBorderBatch(imageUrls, borderWidth) {
      return Promise.all(imageUrls.map(url => addWhiteBorder(url, borderWidth)));
    }

    function displayStickers() {
      const grid = document.getElementById('stickerGrid');
      grid.innerHTML = '';

      stickers.forEach((sticker, index) => {
        const div = document.createElement('div');
        div.className = 'sticker-item';
        div.onclick = () => downloadImage(sticker, `sticker_${index + 1}.png`);
        
        const img = document.createElement('img');
        img.src = sticker;
        div.appendChild(img);
        
        grid.appendChild(div);
      });
    }

    function downloadImage(dataUrl, filename) {
      const link = document.createElement('a');
      link.href = dataUrl;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    async function downloadAllAsZip() {
      if (stickers.length === 0) {
        alert('æ²’æœ‰å¯ä¸‹è¼‰çš„è²¼åœ–ï¼');
        return;
      }

      try {
        const zip = new JSZip();

        for (let i = 0; i < stickers.length; i++) {
          const base64Data = stickers[i].split(',')[1];
          zip.file(`sticker_${i + 1}.png`, base64Data, { base64: true });
        }

        const blob = await zip.generateAsync({ type: 'blob' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'line_stickers.zip';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);

        alert('ä¸‹è¼‰æˆåŠŸï¼');
      } catch (error) {
        alert('ä¸‹è¼‰å¤±æ•—ï¼š' + error.message);
        console.error(error);
      }
    }

    function showProgress(text, progress) {
      document.getElementById('progressCard').style.display = 'block';
      document.getElementById('statusText').textContent = text;
      document.getElementById('progressFill').style.width = progress + '%';
    }

    function updateProgress(progress) {
      document.getElementById('progressFill').style.width = progress + '%';
    }

    function hideProgress() {
      setTimeout(() => {
        document.getElementById('progressCard').style.display = 'none';
      }, 500);
    }

    // Close modal when clicking outside
    document.getElementById('apiKeyModal').addEventListener('click', (e) => {
      if (e.target.id === 'apiKeyModal') {
        document.getElementById('apiKeyModal').classList.remove('show');
      }
    });

    // Initialize on load
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
